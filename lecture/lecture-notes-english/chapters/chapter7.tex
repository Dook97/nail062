\chapter{Tableau Method in Predicate Logic}

In this chapter, we will demonstrate how to generalize the \emph{analytic tableau method} from propositional logic to predicate logic.\footnote{At this point, it is helpful to revisit the tableau method in propositional logic, see Chapter \ref{chapter:tableau-method-propositional}.} The method operates similarly but must handle \emph{quantifiers}.

\section{Informal Introduction}

In this section, we will informally introduce the tableau method. Formal definitions will follow later. We will start with two examples illustrating how the tableau method works in predicate logic and how it deals with quantifiers.

\begin{example} Figure \ref{figure:predicate-tableau-intro-examples} shows two tableaux. These are tableau proofs (in logic, i.e., from an empty theory) of the \emph{sentences} $(\exists x)\neg P(x)\limplies\neg(\forall x)P(x)$ (right) and $\neg(\forall x)P(x)\limplies(\exists x)\neg P(x)$ (left) in the language $L=\langle P\rangle$ (without equality), where $P$ is a unary relational symbol. The symbol $c_0$ is an \emph{auxiliary constant symbol} that we add to the language during the construction of the tableau.

\begin{figure}[htbp]
\begin{minipage}{.49\textwidth}
\centering
\begin{forest}
    for tree={math content}
    [\F(\exists x)\neg P(x)\limplies\neg(\forall x)P(x)
        [\textcolor{red}{\T(\exists x)\neg P(x)}
            [\F\neg(\forall x)P(x)
                [\textcolor{blue}{\T(\forall x)P(x)}
                    [\T\neg P(c_0)
                        [\F P(c_0)
                            [\textcolor{blue}{\T(\forall x)P(x)}
                                [\T P(c_0), tikz={\node[fit to=tree,label=below:$\otimes$] {};}]
                            ]
                        ]
                    ]                
                ]
            ]
        ]
    ]
\end{forest}
\end{minipage}
\begin{minipage}{.49\textwidth}
\centering
\begin{forest}
    for tree={math content}
    [\F\neg(\forall x)P(x)\limplies(\exists x)\neg P(x)
        [\T\neg(\forall x) P(x)
            [\textcolor{blue}{\F(\exists x)\neg P(x)}
                [\textcolor{red}{\F(\forall x)P(x)}
                    [\F P(c_0)
                        [\textcolor{blue}{\F (\exists x)\neg P(x)}
                            [\F\neg P(c_0)
                                [\T P(c_0), tikz={\node[fit to=tree,label=below:$\otimes$] {};}]
                            ]
                        ]
                    ]                
                ]
            ]
        ]
    ]
\end{forest}
\end{minipage}
\label{figure:predicate-tableau-intro-examples}
\caption{Example tableaux. Items of the `witness' type are shown in red, items of the `all' type in blue.}
\end{figure}
\end{example}


\subsubsection{Items}
Formulas in items must always be \emph{sentences} because we need them to have a \emph{truth value} in a given model (independently of the variable assignment). This is not a significant restriction; if we want to prove that a formula $\varphi$ holds in a theory $T$, we can first replace the formula $\varphi$ and all the axioms of $T$ with their \emph{general closures} (i.e., universally quantify all free variables). This yields a \emph{closed} theory $T'$ and a sentence $\varphi'$, and it holds that $T'\models\varphi'$ if and only if $T\models\varphi$.

\subsubsection{Quantifiers}
The reduction of items works the same way, using the same atomic tableaux for logical connectives (see Table \ref{table:atomic-tableaux}, where instead of propositions, $\varphi,\psi$ are sentences). However, we must add four new atomic tableaux for $\mathrm T/\mathrm F$ and universal/existential quantifiers. These items are divided into two types:
\begin{itemize}
    \item Type ``\emph{witness}'': items of the form $\mathrm{T}(\exists x)\varphi(x)$ and $\mathrm{F}(\forall x)\varphi(x)$
    \item Type ``\emph{all}'': items of the form $\mathrm{T}(\forall x)\varphi(x)$ and $\mathrm{F}(\exists x)\varphi(x)$    
\end{itemize}
Examples can be seen in the tableaux in Figure \ref{figure:predicate-tableau-intro-examples} (`witnesses' are in red, `all' in blue).

We cannot simply remove the quantifier because the resulting formula $\varphi(x)$ would not be a sentence. Instead, simultaneously with removing the quantifier, we \emph{substitute} a \emph{constant term} for $x$, resulting in the new item being the \emph{sentence} $\varphi(x/t)$. The constant term $t$ we substitute depends on whether it is a ``witness'' or ``all'' type item.

\subsubsection{Auxiliary Constant Symbols}
The language $L$ of the theory $T$ in which we are proving is extended with a countable number of \emph{new (auxiliary) constant symbols} $C=\{c_0,c_1,c_2,\dots\}$ (but we will also write $c,d,\dots$), and the resulting extended language is denoted $L_C$. Thus, constant terms in the language $L_C$ exist even if the original language $L$ has no constants. When constructing the tableau, we always have some \emph{new}, previously \emph{unused} (in the theory or in the constructed tableau) auxiliary constant symbol $c\in C$ available.

\subsubsection{Witnesses}
When reducing a ``witness'' type item, we substitute for the variable one of these new, auxiliary symbols that \emph{has not yet been used on the given branch}. For an item $\T(\exists x)\varphi(x)$, we thus get $\T\varphi(x/c)$. This constant symbol $c$ will represent (some) element that satisfies the formula (or refutes it, in the case of an item of the form $\F(\forall x)\varphi(x)$). Compare this with the Constant Theorem (Theorem \ref{theorem:on-constants}). It is important that the symbol $c$ has not yet been used on the branch or in the theory. Typically, we then use ``all'' type items to learn what must \emph{hold about this witness}.

In Figure \ref{figure:predicate-tableau-intro-examples}, we see an example: the item $\T(\exists x)\neg P(x)$ in the left tableau is reduced, with its reduction resulting in the item $\T\neg P(c_0)$; $c_0\in C$ is an auxiliary symbol that has not yet appeared on the branch (and is the first such). Similarly for the item $\F(\forall x)P(x)$ and $\F P(c_0)$ in the right tableau.

\subsubsection{All}
When reducing an ``all'' type item, we substitute for the variable $x$ any \emph{constant term} $t$ of the extended language $L_C$. From an item of the form $\T(\forall x)\varphi(x)$, we thus get the item $\T\varphi(x/t)$.

However, for a branch to be \emph{completed}, it must contain items $\T\varphi(x/t)$ for \emph{all} constant $L_C$-terms $t$. (We must `use' everything the item $\T(\forall x)\varphi(x)$ `says'.) The same applies for an item of the form $\mathrm{F}(\exists x)\varphi(x)$.

In propositional logic, we used the convention of omitting the roots of atomic tableaux when connecting them (otherwise, we would repeat the same item twice on the branch). In predicate logic, we will use the same convention but \emph{with the exception of `all' type items}. We will write the root of the connected atomic tableau as well. Why do we do this? To remind ourselves that we are not yet finished with this item and that we must connect atomic tableaux with other constant terms.

In Figure \ref{figure:predicate-tableau-intro-examples}, the item $\T(\forall x)P(x)$ in the left tableau is \emph{not} \emph{reduced}. Its \emph{first occurrence} (4th node from the top) has been reduced, substituting the term $t=c_0$, resulting in $\varphi(x/t)=P(c_0)$. We have connected an atomic tableau consisting of the same item at the root $\T(\forall x)P(x)$, which we \emph{write} in the tableau, and the item $\T P(c_0)$ below it. While the \emph{first occurrence} of the item $\T(\forall x)P(x)$ is thus reduced, the \emph{second occurrence} (7th node from the top) is not. Similarly for the item $\F(\exists x)\neg P(x)$ in the right tableau.

This somewhat technical approach to defining the \emph{reducedness} of (occurrences of) `all' type items will be useful in defining a \emph{systematic tableau}.

\subsubsection{Language}

We will assume that the language $L$ is \emph{countable}.\footnote{This is not a significant limitation from the perspective of computational logic.} As a result, any $L$-theory $T$ has only countably many axioms, and there are also only countably many constant terms in the language $L_C$. This restriction is necessary because every tableau, even an infinite one, has only countably many items, and we must be able to use all the axioms of the given theory and substitute all the constant terms of the language $L_C$.

We will also initially assume that it is a language \emph{without equality}, which is simpler. The problem is that \emph{the tableau} is a purely syntactic object, but \emph{equality} has a special semantic meaning: it must be interpreted as the identity relation in every model. How to adapt the method for languages with equality will be shown later.

\section{Formal Definitions}

In this section, we will define all the concepts needed for the tableau method for languages without equality. We will return to languages with equality in Section \ref{section:tableaux-equality}.

Let $L$ be a \emph{countable} language without equality. Denote by $L_C$ the extension of the language $L$ with countably many new \emph{auxiliary} constant symbols $C=\{c_i\mid i\in \mathbb N\}$. Let us choose some numbering of the constant terms of the language $L_C$, denoted by $\{t_i\mid i\in\mathbb N\}$.

Let $T$ be some $L$-theory and $\varphi$ an $L$-sentence.

\subsection{Atomic Tableaux}

An \emph{item} is a label $\T\varphi$ or $\F\varphi$, where $\varphi$ is some $L_C$-sentence. Items of the form $\T(\exists x)\varphi(x)$ and $\F(\forall x)\varphi(x)$ are of the \emph{`witness' type}, while items of the form $\T(\forall x)\varphi(x)$ and $\F(\exists x)\varphi(x)$ are of the \emph{`all' type}.

\emph{Atomic tableaux} are labeled trees shown in Tables \ref{table:predicate-atomic-tableaux-logical} and \ref{table:predicate-atomic-tableaux-quantifiers}.

\begin{table}[htbp]
\centering
\begin{tabular}{@{}c||c|c|c|c|c@{}}
 & $\neg$ & $\land$ & $\lor$ & $\limplies$ & $\liff$  \\ \midrule \midrule
True
&  
\begin{forest}
[$\mathrm{T}\neg\varphi$ [$\mathrm{F}\varphi$]]
\end{forest}
&  
\begin{forest}
[$\mathrm{T}\varphi\land\psi$ [$\mathrm{T}\varphi$ [$\mathrm{T}\psi$]]]
\end{forest}
& 
\begin{forest}
[$\mathrm{T}\varphi\lor\psi$ [$\mathrm{T}\varphi$] [$\mathrm{T}\psi$]]
\end{forest}
&
\begin{forest}
[$\mathrm{T}\varphi\limplies\psi$ [$\mathrm{F}\varphi$] [$\mathrm{T}\psi$]]
\end{forest}
&  
\begin{forest}
[$\mathrm{T}\varphi\liff\psi$ [$\mathrm{T}\varphi$ [$\mathrm{T}\psi$]] [$\mathrm{F}\varphi$ [$\mathrm{F}\psi$]]]
\end{forest}
\\ \midrule
False 
& 
\begin{forest}
[$\mathrm{F}\neg\varphi$ [$\mathrm{T}\varphi$]]
\end{forest}
&
\begin{forest}
[$\mathrm{F}\varphi\land\psi$ [$\mathrm{F}\varphi$] [$\mathrm{F}\psi$]]
\end{forest}
&
\begin{forest}
[$\mathrm{F}\varphi\lor\psi$ [$\mathrm{F}\varphi$ [$\mathrm{F}\psi$]]]
\end{forest}
&
\begin{forest}
[$\mathrm{F}\varphi\limplies\psi$ [$\mathrm{T}\varphi$ [$\mathrm{F}\psi$]]]
\end{forest}
&
\begin{forest}
[$\mathrm{F}\varphi\liff\psi$ [$\mathrm{T}\varphi$ [$\mathrm{F}\psi$]] [$\mathrm{F}\varphi$ [$\mathrm{T}\psi$]]]
\end{forest}
\end{tabular}
\caption{Atomic tableaux for logical connectives; $\varphi$ and $\psi$ are any $L_C$-sentences.}
\label{table:predicate-atomic-tableaux-logical}
\end{table}


\begin{table}[htbp]
    \centering
    \begin{tabular}{@{}c||c|c@{}}
     & $\forall$ & $\exists$ \\ \midrule \midrule
    True
    &  
    \begin{forest}
        [$\T(\forall x)\varphi(x)$ [$\T\varphi(x/t_i)$]]
    \end{forest}
    &  
    \begin{forest}
        [$\T(\exists x)\varphi(x)$ [$\T\varphi(x/c_i)$]]
    \end{forest}
    \\ \midrule
    False 
    &  
    \begin{forest}
        [$\F(\forall x)\varphi(x)$ [$\F\varphi(x/c_i)$]]
    \end{forest}
    &  
    \begin{forest}
        [$\F(\exists x)\varphi(x)$ [$\F\varphi(x/t_i)$]]
    \end{forest} 
    \end{tabular}
    \caption{Atomic tableaux for quantifiers; $\varphi$ is an $L_C$-sentence, $x$ a variable, $t_i$ any constant $L_C$-term, $c_i\in C$ is a new auxiliary constant symbol (not yet occurring on the given branch of the constructed tableau).}
    \label{table:predicate-atomic-tableaux-quantifiers}
\end{table}

\subsection{Tableau Proof}

The definitions in this section are almost identical to the corresponding definitions from propositional logic. The main technical problem is how to define the reducedness of `all' type items on a branch of the tableau: we want all \emph{constant} $L_C$ terms $t_i$ to be substituted for the variable.

\begin{definition}[Tableau]
    A \emph{finite tableau from theory $T$} is an ordered, labeled tree constructed by applying finitely many of the following rules:
    \begin{itemize}
        \item A single-node tree labeled with any item is a tableau from theory $T$,
        \item For any item $P$ on any branch $V$, we can attach an atomic tableau for item $P$ to the end of branch $V$, provided that if $P$ is a `witness' type, we use only an auxiliary constant symbol $c_i\in C$ not yet appearing on branch $V$ (for `all' type items, we can use any constant $L_C$-term $t_i$),
        \item We can attach the item $\mathrm{T}\alpha$ for any axiom $\alpha\in T$ to the end of any branch.
    \end{itemize}
    A \emph{tableau from theory $T$} can be either finite or \emph{infinite}: in which case it is constructed in countably many steps. It can be formally expressed as the union $\tau=\bigcup_{i\geq 0}\tau_i$, where $\tau_i$ are finite tableaux from $T$, $\tau_0$ is a single-node tableau, and $\tau_{i+1}$ is constructed from $\tau_i$ in one step.\footnote{Union because in each step, we add new nodes to the tableau, so $\tau_i$ is a subtree of $\tau_{i+1}$.}
    
    A tableau \emph{for item $P$} is a tableau with item $P$ at the root.
\end{definition}
    
Recall the convention that if $P$ is \emph{not} of the `all' type, we omit the root of the atomic tableau (since the node with item $P$ is already in the tableau).

\begin{exercise}
    Show step-by-step how the tableaux from Figure \ref{figure:predicate-tableau-intro-examples} were constructed.
\end{exercise}


\begin{definition}[Tableau Proof]
    A \emph{tableau proof} of a sentence $\varphi$ from a theory $T$ is a \emph{contradictory} tableau from theory $T$ with the item $\mathrm{F}\varphi$ at the root. If such a proof exists, then $\varphi$ is \emph{(tableau) provable} from $T$, denoted by $T\proves\varphi$. (We also define a \emph{tableau refutation} as a contradictory tableau with $\mathrm{T}\varphi$ at the root. If such a proof exists, then $\varphi$ is \emph{(tableau) refutable} from $T$, i.e., $T\proves\neg\varphi$ holds.)  
    \begin{itemize}
        \item A tableau is \emph{contradictory} if each of its branches is contradictory.
        \item A branch is \emph{contradictory} if it contains items $\mathrm{T}\psi$ and $\mathrm{F}\psi$ for some sentence $\psi$, otherwise it is \emph{consistent}.
        \item A tableau is \emph{completed} if each of its branches is completed.
        \item A branch is \emph{completed} if 
        \begin{itemize}
            \item it is contradictory, or
            \item each item on this branch is \emph{reduced} and the branch contains the item $\mathrm{T}\alpha$ for each axiom $\alpha\in T$.
        \end{itemize}
         
        \item An item $P$ is \emph{reduced} on a branch $V$ passing through this item if 
        \begin{itemize}
            \item it is of the form $\mathrm{T}\psi$ or $\mathrm{F}\psi$ for an \emph{atomic sentence} $\psi$ (i.e., $R(t_1,\dots,t_n)$, where $t_i$ are \emph{constant} $L_C$-terms), or
            \item it is not of the `all' type and appears on $V$ as the root of an atomic tableau\footnote{Even though by convention we do not write this root.} (i.e., typically, the item has already been developed on $V$ during the tableau construction), or
            \item it is of the `all' type and all its \emph{occurrences} on $V$ are reduced on the branch $V$.
        \end{itemize}
        \item An occurrence of an `all' type item $P$ on branch $V$ is \emph{$i$-th} if it has exactly $i-1$ predecessors labeled with this item on $V$, and the $i$-th occurrence is \emph{reduced} on $V$ if
        \begin{itemize}
            \item the item $P$ has the $(i+1)$-th occurrence on $V$, and simultaneously
            \item the branch $V$ contains the item $\T\varphi(x/t_i)$ (if $P=\T(\forall x)\varphi(x)$) or $\F\varphi(x/t_i)$ (if $P=\F(\exists x)\varphi(x)$), where $t_i$ is the $i$-th constant $L_C$-term.\footnote{I.e., (typically) we have already substituted the term $t_i$ for $x$.}
        \end{itemize} 
    \end{itemize}
\end{definition}
Note that if an `all' type item is reduced on some branch, it must have infinitely many occurrences on that branch, and we must have used all possibilities, i.e., all constant $L_C$ terms, in the substitutions.

\begin{example}\label{example:tableau-proofs}
As an example, let us construct tableau proofs \emph{in logic} (from an empty theory) of the following sentences: 
        \begin{enumerate}[(a)]
            \item $(\forall x)(P(x) \limplies Q(x)) \limplies ((\forall x)P(x) \limplies (\forall x)Q(x))$, where $P,Q$ are unary relational symbols.
            \item $(\forall x)(\varphi(x) \land \psi(x)) \liff((\forall x)\varphi (x) \land (\forall x)\psi(x))$, where $\varphi(x),\psi(x)$ are arbitrary formulas with the single free variable $x$.
        \end{enumerate}
The resulting tableaux are in Figures \ref{figure:predicate-tableau-more-examples-a} and \ref{figure:predicate-tableau-more-examples-b}. The pairs of contradictory items are shown in red. Consider how the tableaux were constructed step-by-step.
\begin{figure}[htbp]
\centering
\begin{forest}
    for tree={math content}
    [\F(\forall x)(P(x) \limplies Q(x)) \limplies ((\forall x)P(x) \limplies (\forall x)Q(x))
        [\T(\forall x)(P(x) \limplies Q(x))
            [\F(\forall x)P(x) \limplies (\forall x)Q(x)
                [\T(\forall x)P(x)
                    [\F(\forall x)Q(x)
                        [\textcolor{red}{\F Q(c_0)}
                            [\T(\forall x)P(x)
                                [\textcolor{red}{\T P(c_0)}
                                    [\T(\forall x)(P(x) \limplies Q(x))
                                        [\T P(c_0)\limplies Q(c_0)
                                            [\textcolor{red}{\F P(c_0)}, tikz={\node[fit to=tree,label=below:$\otimes$] {};}]
                                            [\textcolor{red}{\T Q(c_0)}, tikz={\node[fit to=tree,label=below:$\otimes$] {};}]            
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ]                
                ]
            ]
        ]
    ]
\end{forest}
\caption{Tableau proof from Example \ref{example:tableau-proofs} (a).}
\label{figure:predicate-tableau-more-examples-a}
\end{figure} 

\begin{figure}[htbp]
\centering
\begin{forest}
for tree={math content}
[\F(\forall x)(\varphi(x) \land \psi(x)) \liff((\forall x)\varphi (x) \land (\forall x)\psi(x))
    [\T(\forall x)(\varphi(x) \land \psi(x))
        [\F(\forall x)\varphi (x) \land (\forall x)\psi(x)
            [\F(\forall x)\varphi (x)
                [\textcolor{red}{\F\varphi(c_0)}
                    [\T(\forall x)(\varphi(x) \land \psi(x))
                        [\T\varphi(c_0) \land \psi(c_0)
                            [\textcolor{red}{\T\varphi(c_0)}
                                [\T\psi(c_0), tikz={\node[fit to=tree,label=below:$\otimes$] {};}]
                            ]
                        ]
                    ]
                ]
            ]
            [\F(\forall x)\psi(x)
                [\textcolor{red}{\F\psi(c_0)}
                    [\T(\forall x)(\varphi(x) \land \psi(x))
                        [\T\varphi(c_0) \land \psi(c_0)
                            [\T\varphi(c_0)
                                [\textcolor{red}{\T\psi(c_0)}, tikz={\node[fit to=tree,label=below:$\otimes$] {};}]
                            ]
                        ]
                    ]
                ]
            ]
        ]
    ]
    [\F(\forall x)(\varphi(x) \land \psi(x))
        [\T(\forall x)\varphi (x) \land (\forall x)\psi(x)
            [\T(\forall x)\varphi (x)
                [\T(\forall x)\psi(x)
                    [\F(\varphi(c_0) \land \psi(c_0))
                        [\textcolor{red}{\F\varphi(c_0)}
                            [\T(\forall x)\varphi (x)
                                [\textcolor{red}{\T\varphi(c_0)}, tikz={\node[fit to=tree,label=below:$\otimes$] {};}]
                            ]
                        ]
                        [\textcolor{red}{\F\psi(c_0)}
                            [\T(\forall x)\psi (x)
                                [\textcolor{red}{\T\psi(c_0)}, tikz={\node[fit to=tree,label=below:$\otimes$] {};}]
                            ]
                        ]
                    ]                
                ]
            ]
        ]
    ]
]
\end{forest}
\caption{Tableau proof from Example \ref{example:tableau-proofs} (b). The constant $c_0$ can be used as \emph{new} in all three cases. It is sufficient that it does not yet occur \emph{on the given branch}.}
\label{figure:predicate-tableau-more-examples-b}
\end{figure} 
\end{example}


\subsection{Systematic Tableau and Finiteness of Proofs}

In Section \ref{section:finiteness-and-systematicity-of-proofs}, we showed that if we do not extend contradictory branches (which we do not have to do), then a contradictory tableau, especially a tableau proof, will always be finite. The same proof applies to predicate logic.

\begin{corollary}[Finiteness of Proofs]\label{corollary:finiteness-of-proofs-predicate}
    If $T\proves\varphi$, then there also exists a \emph{finite} tableau proof of $\varphi$ from $T$.
\end{corollary}
\begin{proof}
The same as in propositional logic, see the proof of Corollary \ref{corollary:finiteness-of-proofs}.
\end{proof}

In the same section, we also showed the construction of a \emph{systematic tableau}. This can also be easily adapted to predicate logic. We must ensure that we eventually reduce each item, use every axiom, and now, in predicate logic, also substitute every $L_C$ term $t_i$ for the variable in `all' type items.

\begin{definition}
Let $R$ be an item and $T=\{\alpha_0,\alpha_1,\alpha_2,\dots\}$ a theory. A \emph{systematic tableau} from theory $T$ for item $R$ is a tableau $\tau=\bigcup_{i\geq 0}\tau_i$, where $\tau_0$ is a single-node tableau with item $R$, and for each $i\geq 0$:

Let $P$ be an item at the leftmost node $v$ at the smallest level of the tableau $\tau_i$ that is not reduced on some consistent branch passing through $P$ (or, if the item is of the `all' type, its \emph{occurrence} in this node is not reduced). Then $\tau_i'$ is the tableau constructed from $\tau_i$ by attaching an atomic tableau for $P$ to each consistent branch passing through $v$, where
\begin{itemize}
    \item If $P$ is of the `all' type and has the $k$-th occurrence in node $v$, then we substitute the $k$-th $L_C$ term $t_k$ for the variable.
    \item If $P$ is of the `witness' type, then on the given branch $V$, we substitute $c_i\in C$ with the smallest possible $i$ (such that $c_i$ does not yet occur on $V$).
\end{itemize}
Otherwise, if such an item $P$ and node $v$ do not exist, i.e., all items are reduced, we define $\tau_i'=\tau_i$.

The tableau $\tau_{i+1}$ is then the tableau constructed from $\tau_i'$ by attaching $\mathrm{T}\alpha_i$ to each consistent branch of $\tau_i'$, if $i\leq |T|$. Otherwise (if $T$ is finite and we have used all the axioms), we skip this step and define $\tau_{i+1}=\tau_i'$. 
\end{definition}

Just as in propositional logic, it holds that the systematic tableau is always completed and provides a finite proof:

\begin{lemma}\label{lemma:systematic-is-finished-predicate}
    The systematic tableau is completed.
\end{lemma}
\begin{proof}
    Similar to the proof in propositional logic (Lemma \ref{lemma:systematic-is-finished}). For `all' type items, note that we reduce the $k$-th occurrence when we encounter it in the construction: by attaching a node with the $(k+1)$-th occurrence and substituting the $k$-th $L_C$ term $t_k$.
\end{proof}

\begin{corollary}[Systematicity of Proofs]\label{corollary:systematicity-of-proofs-predicate}
    If $T\proves\varphi$, then the systematic tableau is (a finite) tableau proof of $\varphi$ from $T$.
\end{corollary}
\begin{proof}
    The same as the proof in propositional logic (Corollary \ref{corollary:systematicity-of-proofs}).
\end{proof}


\section{Languages with Equality} \label{section:tableaux-equality}

Now we will show how to apply the tableau method to languages with equality. What is equality? In mathematics, it can mean different relations in different contexts. Does $1+0=0+1$ hold? If we are talking about integers, then yes, but if we mean arithmetic expressions (or e.g., terms in the language of fields), then the left and right sides are not equal: they are different expressions. \footnote{Similarly, $t_1=t_2$ in Prolog does not mean they are the same term but that the terms $t_1$ and $t_2$ are \emph{unifiable}, see the chapter on resolution in predicate logic.}

Imagine we have a theory $T$ in a language with equality containing constant symbols $c_1,c_2$, a unary function symbol $f$, and a unary relation symbol $P$. Let us have some completed tableau from this theory, and in it an open branch, on which we find the entry $\T c_1=c_2$. We will want to construct a \emph{canonical model} $\A$ for this branch, similar to propositional logic. The entry will mean that in the canonical model it holds $c_1^\A =^\A c_2^\A$, i.e., $(c_1^\A,c_2^\A)\in {=^\A}$. But this is not enough, we also want, for example:
\begin{itemize}
    \item $c_2^\A =^\A c_1^\A$,
    \item $f^\A(c_1^\A) =^\A f^\A(c_2^\A)$,
    \item $c_1^\A \in P^\A$ if and only if $c_2^\A \in P^\A$.
\end{itemize}
In general, we want the relation $=^\A$ to be a so-called \emph{congruence},\footnote{The name comes from congruence modulo $n$, which is a congruence in this sense on the set of all integers, e.g., it satisfies: $a+b\equiv c+d\pmod n$ whenever $a\equiv c\pmod n$ and $b\equiv d\pmod n$.} i.e., an equivalence that behaves 'well' with respect to the functions and relations of the structure $\A$. We achieve this by adding so-called \emph{axioms of equality} to the theory $T$, which enforce these properties, and construct the tableau from the resulting theory $T^*$.

In the model $\A$, the relation $=^\A$ will then be a congruence. But this is not enough for us; we want equality to be \emph{identity}, i.e., $(a,b)\in=^\A$ only if $a$ and $b$ are the same element of the universe. We achieve this by identifying all $=^\A$-equivalent elements into a single element. This construction is called a \emph{factor structure} according to the congruence $=^\A$.\footnote{Just as the group $\mathbb Z_n$ is a factor structure of the group $\mathbb Z$ according to $\equiv\pmod n$; for example, the element $2\in\mathbb Z_n$ represents the set of all integers whose remainder after division by $n$ is 2.} Now we formalize these concepts.

\begin{definition}[Congruence]
    Let $\sim$ be an equivalence on the set $A$, $f\colon A^n\to A$ be a function, and $R\subseteq A^n$ be a relation. We say that $\sim$ is
    \begin{itemize}
        \item \emph{a congruence for the function $f$} if for all $a_i,b_i\in A$ such that $a_i\sim b_i$ ($1\leq i\leq n$) it holds that $f(a_1,\dots,a_n)\sim f(b_1,\dots,b_n)$,
        \item \emph{a congruence for the relation $R$} if for all $a_i,b_i\in A$ such that $a_i\sim b_i$ ($1\leq i\leq n$) it holds that $(a_1,\dots,a_n)\in R$ if and only if $(b_1,\dots,b_n)\in R$.
    \end{itemize}    
    \emph{A congruence of the structure} $\A$ is an equivalence $\sim$ on the set $A$ that is a congruence for all functions and relations of $\A$. 
\end{definition}

\begin{definition}[Factor Structure]
    Let $\A$ be a structure and $\sim$ be its congruence. The \emph{factor structure} $\A$ according to $\sim$ is the structure $\A/_\sim$ in the same language, whose universe $A/_\sim$ is the set of all equivalence classes of $A$ according to $\sim$, and whose functions and relations are defined \emph{using representatives}, i.e.:
    \begin{itemize}
        \item $f^{\A/_\sim}([a_1]_\sim,\dots,[a_n]_\sim)=[f^\A(a_1,\dots,a_n)]_\sim$, for each ($n$-ary) function symbol $f$, and
        \item $R^{\A/_\sim}([a_1]_\sim,\dots,[a_n]_\sim)$ if and only if $R^\A(a_1,\dots,a_n)$, for each ($n$-ary) relation symbol~$R$.
    \end{itemize} 
    
\end{definition}


\begin{definition}[Axioms of Equality]
    The \emph{axioms of equality} for a language $L$ with equality are as follows:
    \begin{enumerate}[(i)]
        \item $x=x$,
        \item $x_1=y_1\land\cdots\land x_n=y_n\limplies f(x_1,\dots,x_n)=f(y_1,\dots,y_n)$ for every $n$-ary function symbol $f$ of the language $L$,
        \item $x_1=y_1\land\cdots\land x_n=y_n\limplies (R(x_1,\dots,x_n)\limplies R(y_1,\dots,y_n))$ for every $n$-ary relation symbol $R$ of the language $L$ \emph{including equality}.
    \end{enumerate}
\end{definition}

\begin{exercise}
    The first of the axioms of equality means the reflexivity of the relation $=^\A$. What about symmetry and transitivity? Show that they follow from axiom (iii) for the equality symbol $=$.
\end{exercise}

Thus, from axioms $(i)$ and $(iii)$ it follows that the relation $=^\A$ is an equivalence on $A$, and axioms $(ii)$ and $(iii)$ express that $=^\A$ is a congruence of $\A$. In the tableau method in the case of a language with equality, we implicitly add all the axioms of equality:

\begin{definition}[Tableau Proof with Equality]
    If $T$ is a theory in a language $L$ with equality, then denote as $T^*$ the extension of the theory $T$ by the general closures\footnote{Because in the tableau method we need \emph{sentences}.} of the axioms of equality for the language $L$. A \emph{tableau proof} from the theory $T$ is a \emph{tableau proof} from $T^*$, similarly for tableau refutation (and generally any tableau).    
\end{definition}

The following simple observation holds:
\begin{observation}
    If $\A\models T^*$, then it holds that $\A/_{=^\A}\models T^*$, and in the structure $\A/_{=^\A}$ the equality symbol is interpreted as identity. On the other hand, in any model where the equality symbol is interpreted as identity, the axioms of equality hold.
\end{observation}

We will use this observation in constructing the \emph{canonical model}, which we will need in the proof of the Completeness Theorem. But first, we will prove the Soundness Theorem.

\section{Soundness and Completeness}

In this section, we will prove that the tableau method is sound and complete even in predicate logic. The proofs of both theorems have the same structure as in propositional logic, differing only in the implementation details.

\subsection{Soundness Theorem}

A model (structure) $\A$ \emph{agrees} with an entry $P$ if
$P=\mathrm{T}\varphi$ and $\A\models\varphi$, or $P=\mathrm{F}\varphi$ and $\A\not\models\varphi$. Further, $\A$ agrees with a branch $V$ if it agrees with every entry on that branch.

First, we show an auxiliary lemma analogous to Lemma \ref{lemma:agrees-with-branch}:
\begin{lemma}\label{lemma:agrees-with-branch-predicate}
    If a model $\A$ of the theory $T$ agrees with the entry at the root of the tableau from the theory $T$ (in the language $L$), then $\A$ can be expanded to the language $L_C$ such that it agrees with some branch in the tableau.
\end{lemma}
Note that it suffices to expand $\A$ by new constants $c^\A$ appearing on the branch $V$. Other constant symbols can be interpreted arbitrarily.

\begin{proof}
    Let $\tau=\bigcup_{i\geq 0}\tau_i$ be a tableau from the theory $T$ and a model $\A\in\M_L(T)$ agreeing with the root $\tau$, i.e., with the (single-element) branch $V_0$ in the (single-element) $\tau_0$.
    
    By induction on $i$, we find a sequence of branches $V_i$ and expansions $\A_i$ of the model $\A$ by constants $c^\A\in C$ appearing on $V_i$ such that $V_i$ is a branch in the tableau $\tau_i$ agreeing with the model $\A_i$, $V_{i+1}$ is an extension of $V_i$, and $\A_{i+1}$ is an expansion of $\A_i$ (they may even be equal). The desired branch of the tableau $\tau$ is then $V=\bigcup_{i\geq 0}V_i$. The expansion of the model $\A$ to the language $L_C$ is obtained as the `limit' of the expansions $\A_i$, i.e., if a symbol $c\in C$ appears on $V$, it appears on some branch $V_i$ and we interpret it the same as in $\A_i$ (other auxiliary symbols are interpreted arbitrarily).
    \begin{itemize}
        \item If $\tau_{i+1}$ was created from $\tau_i$ without extending the branch $V_i$, we define $V_{i+1}=V_i$ and $\A_{i+1}=\A_{i}$.
        \item If $\tau_{i+1}$ was created from $\tau_i$ by adding the entry $\mathrm{T}\alpha$ (for some axiom $\alpha\in T$) to the end of the branch $V_i$, we define $V_{i+1}$ as this extended branch and $\A_{i+1}=\A_i$ (we did not add any new auxiliary constant symbol). Since $\A_{i+1}$ is a model of $T$, the axiom $\alpha$ holds in it, so it agrees with the new entry $\mathrm{T}\alpha$.
        \item Suppose $\tau_{i+1}$ was created from $\tau_i$ by attaching an atomic tableau for some entry $P$ to the end of the branch $V_i$. Since the model $\A_i$ agrees with the entry $P$ (which lies on the branch $V_i$), it also agrees with the root of the attached atomic tableau.
        \begin{itemize}
            \item If we attached an atomic tableau for a logical connective, we set $\A_{i+1}=\A_i$ (we did not add a new auxiliary symbol). Since $\A_{i+1}$ agrees with the root of the atomic tableau, it also agrees with one of its branches (just as in propositional logic); we define $V_{i+1}$ as the extension of $V_i$ by this branch.
            \item If the entry $P$ is of the type `witness': If $P=\T(\exists x)\varphi(x)$, then $\A_i\models(\exists x)\varphi(x)$, so there exists $a\in A$ such that $\A_i\models\varphi(x)[e(x/a)]$. We define the branch $V_{i+1}$ as the extension of $V_i$ by the newly added entry $\T\varphi(x/c)$ and the model $\A_{i+1}$ as the expansion of $\A_i$ by the constant $c^A=a$. The case $P=\F(\forall x)\varphi(x)$ is analogous.
            \item If the entry $P$ is of the type `all', we define the branch $V_{i+1}$ as the extension of $V_i$ by the atomic tableau. The newly added entry is $\T\varphi(x/t)$ or $\F\varphi(x/t)$ for some $L_C$ term $t$. Suppose it is the first of these two possibilities, for the second the proof is analogous. 
            We define the model $\A_{i+1}$ as \emph{any} expansion of $\A_i$ by the new constants appearing in $t$.    
            Since $\A_i\models(\forall x)\varphi(x)$, it also holds $\A_{i+1}\models(\forall x)\varphi(x)$ and thus $\A_{i+1}\models\varphi(x/t)$; the model $\A_{i+1}$ thus agrees with the branch $V_i$.
        \end{itemize}       
    \end{itemize}
\end{proof}

Let's briefly recall the idea of the proof of the Soundness Theorem: If there existed a proof and at the same time a counterexample, the counterexample would have to agree with some branch of the proof, but they are all contradictory. The proof is thus almost the same as in propositional logic.

\begin{theorem}[On Soundness]
If a sentence $\varphi$ is tableau provable from a theory $T$, then $\varphi$ is true in $T$, i.e., $T\proves\varphi\ \Rightarrow\ T\models\varphi$.    
\end{theorem}

\begin{proof}
Assume for contradiction that $T\not\models\varphi$, i.e., there exists $\A\in\M(T)$ such that $\A\not\models\varphi$. Since $T\proves\varphi$, there exists a contradictory tableau from $T$ with $\mathrm{F}\varphi$ at the root. The model $\A$ agrees with $\mathrm{F}\varphi$, so by Lemma \ref{lemma:agrees-with-branch-predicate} it can be expanded to the language $L_C$ such that the expansion agrees with some branch $V$. But all branches are contradictory.
\end{proof}


\subsection{Věta o úplnosti}

Stejně jako ve výrokové logice ukážeme, že \emph{bezesporná} větev v \emph{dokončeném} tablo důkazu poskytuje protipříklad: model teorie $T$, který se shoduje s položkou $\mathrm{F}\varphi$ v kořeni tabla, tj. neplatí v něm $\varphi$. Takových modelů může být více, definujeme proto opět jeden konkrétní, \emph{kanonický}.

Model musí mít nějakou doménu. Jak ji získat z tabla, což je čistě syntaktický objekt? Využijeme standardní (v matematice) trik: ze syntaktických objektů uděláme sémantické. Konkrétně, za doménu zvolíme množinu všech \emph{konstantních termů} jazyka $L_C$.\footnote{Tj. termů zbudovaných aplikací funkčních symbolů jazyka $L$ na konstantní symboly jazyka $L$ (má-li nějaké) a pomocné konstantní symboly z $C$.} Ty chápeme jako konečné řetězce. V následujícím výkladu budeme někdy (neformálně) místo termu $t$ psát ``$t$'', abychom zdůraznili, že v daném místě chápeme $t$ jako řetězec znaků, a ne např. jako termovou funkci, kterou je třeba vyhodnotit.\footnote{Srovnejte aritmetický výraz ``1+1'' a 1+1=2.}

\begin{definition}[Kanonický model]\label{definition:canonical-model-predicate}
Mějme teorii $T$ v jazyce $L=\langle\mathcal F,\mathcal R\rangle$ a nechť $V$ je bezesporná větev nějakého dokončeného tabla z teorie $T$. Potom \emph{kanonický model} pro $V$ je $L_C$-struktura $\A=\langle A,\mathcal F^\mathcal A\cup C^\mathcal A,\mathcal R^\mathcal A\rangle$ definovaná následovně:

Je-li jazyk $L$ bez rovnosti, potom:
\begin{itemize}
    \item Doména $A$ je množina všech konstantních $L_C$-termů.
    \item Pro každý $n$-ární relační symbol $R\in\mathcal R$ a ``$s_1$'', \dots, ``$s_n$'' z $A$:
    $$
    (\text{``$s_1$''},\dots,\text{``$s_n$''})\in R^\mathcal A\text{ právě když na větvi $V$ je položka $\T R(s_1,\dots,s_n)$}
    $$
    \item Pro každý $n$-ární funkční symbol $f\in\mathcal F$ a ``$s_1$'', \dots, ``$s_n$'' z $A$:
    $$
    f^\mathcal A(\text{``$s_1$''},\dots,\text{``$s_n$''})=\text{``$f(s_1,\dots,s_n)$''}
    $$
    Speciálně, pro konstantní symbol $c$ máme $c^\mathcal A=\text{``$c$''}$.
\end{itemize}
Funkci $f^\mathcal A$ tedy interpretujeme jako `vytvoření' nového termu ze symbolu $f$ a vstupních termů (řetězců). 

Nechť je $L$ jazyk s rovností. Připomeňme, že naše tablo je nyní z teorie $T^*$, tj. z rozšíření~$T$ o axiomy rovnosti pro $L$. Nejprve vytvoříme kanonický model $\mathcal B$ pro $V$ jako by byl $L$ bez rovnosti (jeho doména $B$ je tedy množina všech konstantních $L_C$-termů). Dále definujeme relaci $=^B$ stejně jako pro ostatní relační symboly:
$$
\text{``$s_1$''}=^B\text{``$s_2$''}\text{ právě když na větvi $V$ je položka $\T s_1=s_2$}
$$
\emph{Kanonický model} pro $V$ potom definujeme jako faktorstrukturu $\A=\B/_{=^B}$.
\end{definition}

Jak plyne z diskuze v Sekci \ref{section:tableaux-equality}, relace $=^B$ je opravdu kongruence struktury $\B$, definice je tedy korektní, a relace $=^\A$ je identita na $A$. Platí následující jednoduché pozorování:


\begin{observation}\label{canonical-with-equality-satisfies-the-same}
    Pro každou formuli $\varphi$ máme $\B\models\varphi$ (kde symbol $=$ je interpretován jako binární relace $=^B$), právě když $\A=\B/_{=^B}\models\varphi$ (kde $=$ je interpretován jako identita).    
\end{observation}


Všimněte si, že v jazyce bez rovnosti je kanonický model vždy spočetně nekonečný. V jazyce s rovností může ale být konečný, jak uvidíme v následujících příkladech.

\begin{example}
    Nejprve si ukažme příklad kanonického modelu v jazyce bez rovnosti. Mějme teorii $T=\{(\forall x)R(f(x))\}$ v jazyce $L=\langle R,f,d \rangle$ bez rovnosti, kde $R$ je unární relační, $f$ unární funkční, a $d$ konstantní symbol. Najděme protipříklad ukazující, že $T\not\models\neg R(d)$. 
    
    Systematické tablo z $T$ s položkou $\F\neg R(d)$ v kořeni není sporné, obsahuje jedinou větev $V$, která je bezesporná. (Sestrojte si tablo sami!) Kanonický model pro $V$ je $L_C$-struktura $\A=\langle A,R^\A,f^\A,d^\A,c_0^\A,c_1^\A,c_2^\A,\dots\rangle$, jejíž doména je
    $$
    A=\{\text{``$d$''},\text{``$f(d)$''},\text{``$f(f(d))$''},\dots,\text{``$c_0$''},\text{``$f(c_0)$''},\text{``$f(f(c_0))$''},\dots,\text{``$c_1$''},\text{``$f(c_1)$''},\text{``$f(f(c_1))$''},\dots\}
    $$
    a interpretace symbolů jsou následující:
    \begin{itemize}
        \item $d^\A=\text{``$d$''}$,
        \item $c^\A_i=\text{``$c_i$''}$ pro všechna $i\in \mathbb N$,
        \item $f^\A(\text{``$d$''})=\text{``$f(d)$''}$, $f^\A(\text{``$f(d)$''})=\text{``$f(f(d))$''}$, \dots
        \item $R^\A=A\setminus C=\{\text{``$d$''},\text{``$f(d)$''},\text{``$f(f(d))$''},\dots,\text{``$f(c_0)$''},\text{``$f(f(c_0))$''},\dots,\text{``$f(c_1)$''},\text{``$f(f(c_1))$''},\dots\}$.
    \end{itemize}
    Redukt kanonického modelu $\A$ na původní jazyk $L$ je potom $\A'=\langle A, R^\A, f^\A, d^\A\rangle$.
\end{example}

\begin{example}
    Nyní příklad v jazyce s rovností: Mějme teorii $T=\{(\forall x)R(f(x)),(\forall x)(x=f(f(x)))\}$ v jazyce $L=\langle R,f,d \rangle$ s rovností. Opět najděme protipříklad ukazující, že $T\not\models\neg R(d)$. 

    Systematické tablo z teorie $T^*$ (tj. z $T$ rozšířené o axiomy rovnosti pro $L$) s položkou $\F\neg R(d)$ v kořeni obsahuje bezespornou větev $V$. (Sestrojte si tablo sami!) Nejprve sestrojíme kanonický model $\B$ pro tuto větev, jako by byl jazyk bez rovnosti:
    $$
    \B=\langle B,R^\B,f^\B,d^\B,c_0^\B,c_1^\B,c_2^\B,\dots\rangle
    $$
    kde $B$ je množina všech konstantních $L_C$-termů. Relace $=^B$ je definovaná, jako by symbol `$=$' byl `obyčejným' relačním symbolem v $L$. Je to kongruence struktury $\B$, a platí pro ni, že $s_1=^B s_2$ právě když $s_1=f(\cdots (f(s_2))\cdots)$ nebo $s_2=f(\cdots (f(s_1))\cdots)$ pro sudý počet aplikací $f$. Jako reprezentanty jednotlivých tříd tedy můžeme vybrat termy s žádným nebo jedním výskytem symbolu $f$:
    $$
        B/_{=^B} = \{[\text{``$d$''}]_{=^B},[\text{``$f(d)$''}]_{=^B},[\text{``$c_0$''}]_{=^B},[\text{``$f(c_0)$''}]_{=^B},[\text{``$c_1$''}]_{=^B},[\text{``$f(c_1)$''}]_{=^B},\dots\}
    $$
    Kanonický model pro větev $V$ je potom $L_C$-struktura 
    $$
    \A=\B/_{=^B}=\langle A,R^\A,f^\A,d^\A,c_0^\A,c_1^\A,c_2^\A,\dots\rangle
    $$
    kde $A=B/_{=^B}$ a interpretace symbolů jsou následující:
    \begin{itemize}
        \item $d^\A=[\text{``$d$''}]_{=^B}$,
        \item $c^\A_i=[\text{``$c_i$''}]_{=^B}$ pro všechna $i\in \mathbb N$,
        \item $f^\A([\text{``$d$''}]_{=^B})=[\text{``$f(d)$''}]_{=^B}$, $f^\A([\text{``$f(d)$''}]_{=^B})=[\text{``$f(f(d))$''}]_{=^B}=[\text{``$d$''}]_{=^B}$, \dots
        \item $R^\A=A=B/_{=^B}$.
    \end{itemize}
    Redukt kanonického modelu $\A$ na původní jazyk $L$ je opět $\A'=\langle A, R^\A, f^\A, d^\A\rangle$.
\end{example}

\begin{exercise}
    \begin{enumerate}[(a)]
        \item Sestrojte dokončené tablo s položkou $\T (\forall x)(\forall y)(x=y)$ v kořeni. Sestrojte kanonický model pro (jedinou, bezespornou) větev tohoto tabla.
        \item Sestrojte dokončené tablo s položkou $\T (\forall x)(\forall y)(\forall z)(x=y\lor x=z \lor y=z)$ v kořeni. Sestrojte kanonické modely pro několik bezesporných větví a porovnejte je.
    \end{enumerate}
\end{exercise} 

Nyní jsme připraveni dokázat Větu o úplnosti. Použijeme opět následující pomocné lemma, jehož znění je zcela stejné, jako znění Lemmatu \ref{lemma:canonical-model-agrees} a důkaz se liší jen v technických detailech.

\begin{lemma}\label{lemma:canonical-model-agrees-predicate}
    Kanonický model pro (bezespornou dokončenou) větev $V$ se shoduje s $V$.
\end{lemma}
\begin{proof}
Nejprve uvažme jazyky bez rovnosti. Ukážeme indukcí podle struktury sentencí v položkách, že kanonický model $\A$ se shoduje se všemi položkami $P$ na větvi $V$. 

Základ indukce, tj. případ, kdy $\varphi=R(s_1,\dots,s_n)$ je atomická sentence, je jednoduchý: Je-li na $V$ položka $\T\varphi$, potom $(s_1,\dots,s_n)\in R^\A$ plyne přímo z definice kanonického modelu, máme tedy $\A\models\varphi$.  Je-li na $V$ položka $\F\varphi$, potom na $V$ není položka $\T\varphi$ ($V$ je bezesporná), $(s_1,\dots,s_n)\not\in R^\A$, a $\A\not\models\varphi$

Nyní indukční krok. Rozebereme jen několik případů, ostatní se dokáží obdobně. 

Pro logické spojky je důkaz zcela stejný jako ve výrokové logice, například je-li $P=\mathrm{F}\varphi\land\psi$, potom protože je $P$ na $V$ redukovaná, vyskytuje se na $V$ položka $\mathrm{F}\varphi$ nebo položka $\mathrm{F}\psi$. Platí tedy $\A\not\models\varphi$ nebo $\A\not\models\psi$, z čehož plyne $\A\not\models\varphi\land\psi$ a $\A$ se shoduje s $P$.

Máme-li položku typu ``všichni'', například $P=\T(\forall x)\varphi(x)$ 
(případ $P=\F(\exists x)\varphi(x)$ je obdobný), potom jsou na $V$ i položky $T\varphi(x/t)$ pro každý konstantní $L_C$-term, tj. pro každý prvek $\text{``$t$''}\in A$. Dle indukčního předpokladu je $\A\models\varphi(x/t)$ pro každé $\text{``$t$''}\in A$, tedy $\A\models(\forall x)\varphi(x)$.

Máme-li položku typu ``svědek'', například $P=\T(\exists x)\varphi(x)$ 
(případ $P=\F(\forall x)\varphi(x)$ je obdobný), potom je na $V$ i položka $T\varphi(x/c)$ pro nějaké $\text{``$c$''}\in A$. Dle indukčního předpokladu je $\A\models\varphi(x/c)$, tedy i $\A\models(\exists x)\varphi(x)$.

Je-li jazyk s rovností, máme kanonický model $\A=\B/_{=^B}$, důkaz výše platí pro $\B$, a zbytek plyne z Pozorování \ref{canonical-with-equality-satisfies-the-same}.
\end{proof}

\begin{exercise}
    Ověřte zbývající případy v důkazu Lemmatu \ref{lemma:canonical-model-agrees-predicate}.
\end{exercise}

Důkaz Věty o úplnosti je také analogický její verzi pro výrokovou logiku:

\begin{theorem}[O úplnosti]\label{theorem:completeness-theorem-predicate}
    Je-li sentence $\varphi$ pravdivá v teorii $T$, potom je tablo dokazatelná z $T$, tj. $T\models\varphi\ \Rightarrow\ T\proves\varphi$.    
\end{theorem} 

\begin{proof}
Ukážeme, že libovolné \emph{dokončené} tablo z $T$ s položkou $\mathrm{F}\varphi$ v kořeni je nutně sporné. Důkaz provedeme sporem: kdyby takové tablo nebylo sporné, existovala by v něm bezesporná (dokončená) větev $V$. Uvažme kanonický model $\A$ pro tuto větev, a označme jako $\A'$ jeho redukt na jazyk $L$. Protože je $V$ dokončená, obsahuje $\mathrm{T}\alpha$ pro všechny axiomy $\alpha\in T$. Model $\A$ se podle Lemmatu \ref{lemma:canonical-model-agrees-predicate} shoduje se všemi položkami na $V$, splňuje tedy všechny axiomy a máme i $\A'\models T$. Protože se ale $\A$ shoduje i s položkou $\mathrm{F}\varphi$ v kořeni, platí i $\A'\not\models\varphi$, což znamená, že $\A'\in \M_L(T)\setminus\M_L(\varphi)$, tedy $T\not\models\varphi$, a to je spor. Tablo tedy muselo být sporné, tj. být tablo důkazem $\varphi$ z $T$.
\end{proof}


\section{Důsledky korektnosti a úplnosti}

Stejně jako ve výrokové logice, Věty o korektnosti a úplnosti dohromady říkají, že \emph{dokazatelnost} je totéž, co \emph{platnost}. To nám umožňuje obdobně zformulovat syntaktické analogie sémantických pojmů a vlastností.

Analogií \emph{důsledků} jsou \emph{teorémy} teorie $T$:
$$
\Thm_L(T)=\{\varphi\mid \varphi\text{ je $L$-sentence a } T\proves\varphi\}
$$

\begin{corollary}[Dokazatelnost = platnost]\label{corollary:corollary-of-soundness-and-completeness-predicate}
    Pro libovolnou teorii $T$ a sentence $\varphi,\psi$ platí:
    \begin{itemize}
        \item $T\proves\varphi$ právě když $T\models\varphi$
        \item $\Thm_L(T)=\Conseq_L(T)$
    \end{itemize}
\end{corollary}

Platí například:
\begin{itemize}
    \item Teorie je \emph{sporná}, jestliže je v ní dokazatelný spor (tj. $T\proves\bot$).
    \item Teorie je \emph{kompletní}, jestliže pro každou sentenci $\varphi$ je buď $T\proves\varphi$ nebo $T\proves\neg\varphi$ (ale ne obojí, jinak by byla sporná).
    \item Věta o dedukci: Pro teorii $T$ a sentence $\varphi,\psi$ platí $T,\varphi\proves\psi$, právě když $T\proves\varphi\to\psi$.
\end{itemize}

Na závěr této sekce si ukážeme několik aplikací Vět o úplnosti a korektnosti.

\subsection{Löwenheim-Skolemova věta}\label{subsection:loewenheim-skolem-theorem}

\begin{theorem}[Löwenheim-Skolemova]
    Je-li $L$ spočetný jazyk bez rovnosti, potom každá bezesporná $L$-teorie má spočetně nekonečný model.
\end{theorem}

\begin{proof}
Vezměme nějaké dokončené (např. systematické) tablo z teorie $T$ s položkou $\F\bot$ v kořeni. Protože $T$ je bezesporná, není v ní dokazatelný spor, tedy tablo musí obsahovat bezespornou větev. Hledaný spočetně nekonečný model je $L$-redukt kanonického modelu pro tuto větev.
\end{proof}

K této větě se ještě vrátíme v Kapitole \ref{chapter:model-theory}, kde si ukážeme silnější verzi zahrnující i jazyky s rovností (v nich je kanonický model spočetný, ale může být i konečný).

\subsection{Věta o kompaktnosti}

Stejně jako ve výrokové logice platí Věta o kompaktnosti, stejný je i její důkaz:

\begin{theorem}[O kompaktnosti]\label{theorem:compactness-theorem-predicate}
    Teorie má model, právě když každá její konečná část má model.    
\end{theorem}
\begin{proof}
Model teorie je zřejmě modelem každé její části. Naopak, pokud $T$ nemá model, je sporná, tedy $T\proves\bot$. Vezměme nějaký \emph{konečný} tablo důkaz $\bot$ z $T$. K jeho konstrukci stačí konečně mnoho axiomů $T$, ty tvoří konečnou podteorii $T'\subseteq T$, která nemá model.
\end{proof}


\subsection{Nestandardní model přirozených čísel}

Na závěr této sekce si ukážeme, že existuje tzv. \emph{nestandardní model} přirozených čísel. Klíčem je Věta o kompaktnosti.
    
Nechť $\underline{\mathbb N}=\langle\mathbb N,S,+,\cdot,0,\leq\rangle$ je standardní model přirozených čísel. Označme $\Th(\underline{\mathbb N})$ množinu všech sentencí \emph{pravdivých} ve struktuře $\underline{\mathbb N}$ (tzv. \emph{teorii struktury} $\underline{\mathbb N}$). Pro $n\in \mathbb N$ definujme \emph{$n$-tý numerál} jako term $\underline n=S(S(\cdots (S(0)\cdots))$, kde $S$ je aplikováno $n$-krát.

Vezměme nový konstantní symbol $c$ a vyjádřeme, že je ostře větší než každý $n$-tý numerál:
$$
T=\Th(\underline{\mathbb N})\cup\{\underline n<c\mid n\in \mathbb N\}
$$
Všimněte si, že každá konečná část teorie $T$ má model. Z věty o kompaktnosti tedy plyne, že i teorie $T$ má model. Říkáme mu \emph{nestandardní model} (označme ho $\A$). Platí v něm tytéž sentence, které platí ve standardním modelu, ale zároveň obsahuje prvek $c^\A$, který je větší než každé $n\in \mathbb N$ (čímž zde myslíme hodnotu termu $\underline n$ v nestandardním modelu $\A$).
    

\section{Hilbertovský kalkulus v predikátové logice}

Na závěr kapitoly si ukážeme, jak lze adaptovat Hilbertův kalkulus, představený v Sekci \ref{section:hilbert-calculus-propositional}, pro použití v predikátové logice. To není těžké, abychom se vypořádali s kvantifikátory, stačí přidat dvě nová schémata logických axiomů a jedno nové inferenční pravidlo. Opět si ukážeme korektnost tohoto dokazovacího systému, a jen zmíníme, že je také úplný.

Důkazy budou sestávat z libovolných formulí, nejen sentencí. Připomeňme, že Hilbertovský kalkulus používá jen spojky $\neg$ a $\limpliessymb$. Budeme mít obdobné logické axiomy, jako ve výrokové logice; v případě jazyka s rovností navíc přidáme \emph{axiomy rovnosti}. 

\begin{definition}[Schémata axiomů v hilbertovském kalkulu v predikátové logice]
Pro libovolné formule $\varphi,\psi,\chi$, term $t$, a proměnnou $x$ jsou následující formule logickými axiomy:
\begin{enumerate}[(i)]
    \item $\varphi \limplies (\psi \limplies \varphi)$
    \item $(\varphi\limplies (\psi \limplies \chi))\limplies ((\varphi \limplies \psi)\limplies(\varphi \limplies \chi))$
    \item $(\neg \varphi \limplies \neg \psi)\limplies(\psi \limplies \varphi)$
    \item $(\forall x)\varphi \limplies \varphi(x/t)$, je-li $t$ substituovatelný za $x$ do $\varphi$
    \item $(\forall x)(\varphi \to \psi) \limplies (\varphi \limplies (\forall x)\psi)$, není-li $x$ volná ve $\varphi$
\end{enumerate}
Je-li jazyk s rovností, potom jsou logickými axiomy také \emph{axiomy rovnosti} pro daný jazyk.       
\end{definition}

Všimněte si, že všechny logické axiomy jsou opravdu tautologie. Jako odvozovací pravidla nám poslouží \emph{modus ponens} a dále \emph{pravidlo generalizace}: 

\begin{definition}[Modus ponens]
\emph{Modus ponens} říká, že pokud jsme již dokázali $\varphi$ a také  $\varphi\limplies\psi$, můžeme odvodit i formuli $\psi$:
$$
\frac{\varphi, \varphi \limplies \psi}{\psi}
$$ 
\end{definition}

\begin{definition}[Pravidlo generalizace]
    \emph{Pravidlo generalizace} říká, že pokud jsme dokázali $\varphi$, lze odvodit i formuli $(\forall x)\varphi$ (pro libovolnou proměnnou $x$):
    $$
    \frac{\varphi}{(\forall x)\varphi}
    $$ 
\end{definition}

Všimněte si, že obě odvozovací pravidla jsou \emph{korektní}, tj. platí-li v nějaké teorii $T\models\varphi$ a $T\models\varphi\limplies\psi$, máme i $T\models\psi$, a podobně platí-li $T\models\varphi$, platí i $T\models(\forall x)\varphi$.

Stejně jako ve výrokové logice, \emph{důkaz} bude konečná posloupnost formulí, ve které je každá nově napsaná formule buď axiomem (logickým, vč. axiomu rovnosti, nebo z teorie, ve které dokazujeme), nebo lze odvodit z předchozích pomocí jednoho z odvozovacích pravidel:

\begin{definition}[Hilbertovský důkaz]
    \emph{Hilbertovský důkaz} formule $\varphi$ z teorie $T$ je \emph{konečná} posloupnost formulí $\varphi_0, \dots, \varphi_n=\varphi$, ve které pro každé $i\le n$ platí:
    \begin{itemize}
    \item $\varphi_i$ je logický axiom (včetně axiomu rovnosti, je-li jazyk s rovností), nebo
    \item $\varphi_i$ je axiom teorie ($\varphi_i \in T$), nebo
    \item $\varphi_i$ lze odvodit z nějakých předchozích formulí $\varphi_j,\varphi_k$ (kde $j,k<i$) pomocí modus ponens, nebo
    \item $\varphi_i$ lze odvodit z nějaké předchozí formule $\varphi_j$ (kde $j<i$) pomocí pravidla generalizace.
    \end{itemize}
    Existuje-li hilbertovský důkaz, je $\varphi$ \emph{(hilbertovsky) dokazatelná}, píšeme $T\proves_H\varphi$.           
\end{definition}

I v predikátové logice je hilbertovský kalkulus korektní a úplný dokazovací systém.

\begin{theorem}[O korektnosti hilbertovského kalkulu]
Pro každou teorii $T$ a formuli $\varphi$ platí: 
$$
T\proves_H \varphi\ \Rightarrow\ T\models\varphi
$$ 
\end{theorem}
\begin{proof}
Indukcí dle indexu $i$ ukážeme, že každá formule $\varphi_i$ z důkazu (tedy i $\varphi_n=\varphi$) platí v $T$.

Je-li $\varphi_i$ logický axiom (včetně axiomu rovnosti), $T \models \varphi_i$ platí protože logické axiomy jsou tautologie. Je-li $\varphi_i\in T$, také jistě platí $T \models \varphi_i$. Zbytek plyne z korektnosti odvozovacích pravidel.
\end{proof}

Pro úplnost ještě vyslovme úplnost, důkaz ale neuvedeme.

\begin{theorem}[O úplnosti hilbertovského kalkulu]
Pro každou teorii $T$ a formuli $\varphi$ platí: 
$$
T\models\varphi\ \Rightarrow\ T\proves_H\varphi
$$
\end{theorem}
